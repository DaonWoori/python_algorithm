# 두 수의 합 

### 문제 설명 
정수 수열 안에서 수열의 원소 두 개의 합이 target 값이 되는 경우를 찾고 싶습니다
매개변수 nums에 길이가 n인 수열이 주어지고, 매개변수 target에 자연수 값이 주어지면 이 수열안에서 두 개의 원소의 합이 정수 target
값이 되는 두 원소를 구해 배열에 오름차순으로 담아 반환합니다.
두 개의 원소의 합이 target 값이 되는 경우는 오직 한가지 뿐인 입력만 주어집니다. 한 원소를 두 번 더하는 것은 안됩니다.
nums의 각 원소는 유일값입니다. 답이 없을 경우 [0,0]을 반환합니다.

### 입출력 
|nums| target| answer|
|---|---|---|
|[7, 3, 2, 13, 9, 15, 8, 11] |12| [3, 9]|
|[21, 12, 30, 15, 6, 2, 9, 19, 14] |24| [9, 15]|
|[12, 18, 5, 8, 21, 27, 22, 25, 16, 2] |28| [12, 16]|
|[11, 17, 6, 8, 21, 9, 19, 12, 25, 16, 2] |26| [9, 17]|
|[7, 5, 12, -9, -12, 22, -30, -35, -21]| -14| [-21, 7]|
|[7, 5, 12, 20]| 15| [0, 0]|

### 제한사항
* num의 길이 3 <= n <= 10,000
* 배열 nums의 원소는 정수입니다. -10,000 <= nums[i] <= 10,000
* -20,000 <= target <= 20,000

### solution 
```
def solution(nums, target):
    for n in nums:
        if target - n != n and target - n in nums:
            if n > target-n:
                return [target-n, n]
            else:
                return [n, target-n]
    return [0, 0]
        
                                       
print(solution([7, 9, 2, 13, 3, 15, 8, 11], 12))
print(solution([21, 12, 30, 15, 6, 2, 9, 19, 14], 24))
print(solution([12, 18, 5, 8, 21, 27, 22, 25, 16, 2], 28))
print(solution([11, 17, 6, 8, 21, 9, 19, 12, 25, 16, 2], 26))
print(solution([7, 5, 12, -9, -12, 22, -30, -35, -21], -14))
print(solution([7, 5, 12, 20], 15))
```
> * for n in nums: 전체 개수 n개의 원소를 순회 -> O(N)
> * target - n in nums: 매 루프마다 리스트에서 in 연산 -> O(N)
>
> 따라서 최악의 경우 O(N^2)

### references
1) 이중 for문 활용 
```
def solution(nums, target):
    answer = [0] * 2
    for i in range(len(nums)-1):
        for j in range(i+1, len(nums)):
            if nums[i] + nums[j] == target:
                return sorted([nums[i], nums[j]])

    return answer                   
```

2) set 자료형 활용
```
def solution(nums, target):
    num_set = set(nums)
    for n in num_set:
        if target - n in num_set:
            return sorted([n, target-n])
        
    return [0, 0]
```
> * set 자료형의 in연산의 시간복잡도: O(1)
> * sorted([n, target-n]): 정렬 길이가 고정된 작은 수일 때 시간복잡도: O(1)
> 
> 따라서 최종 시간 복잡도는 O(N)
			
			








