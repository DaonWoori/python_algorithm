# 사탕 종류 

### 문제 설명
현수는 사탕을 좋아합니다. 현수에게 사탕이 n개 있습니다.
현수 엄마는 현수가 요즘 너무 사탕을 많이 먹어 건강에 좋지 않다고 생각해 현수에게 가지고
있는 사탕의 절반 (n/2)개만 먹으라고 했습니다. n은 항상 짝수입니다.
매개변수 nums에 현수가 가지고 있는 n개의 사탕의 종류 정보가 주어지면 현수가 n/2개의 
사탕을 먹는다면 최대 몇 종류의 사탕을 먹을 수 있는지를 반환하는 프로그램을 작성하세요.

### 입출력 예
|nums |answer|
|---|---|
|[2, 1, 1, 3, 2, 3, 1, 2] |3|
|[1, 3, 5, 7, 2, 3, 7, 5, 3, 2, 5, 7, 9, 12] |7|
|[5, 5, 5, 5, 5, 5] |1|
|[12, 23, 11, 3, 5, 23, 23, 23, 23, 23, 23, 23] |5|
|[100, 200, 300, 400, 500, 600, 700, 800] |4|

### 제한사항:
* nums의 길이는 100,000을 넘지 않습니다.
* nums[i]는 i번째 사탕의 종류를 의미합니다. nums[i] 값이 같으면 같은 종류의 사탕입니다.
* 1 <= nums[i] <= 1,000

### solution
```
def solution(nums):
    total_candy = len(nums) # 총 사탕의 개수 
    candy_type = len(set(nums)) # 사탕의 종류 

    return candy_type if candy_type <= total_candy // 2 else total_candy // 2
    
                       
print(solution([2, 1, 1, 3, 2, 3, 1, 2]))
print(solution([1, 3, 5, 7, 2, 3, 7, 5, 3, 2, 5, 7, 9, 12]))
print(solution([5, 5, 5, 5, 5, 5]))
print(solution([12, 23, 11, 3, 5, 23, 23, 23, 23, 23, 23, 23]))
print(solution([100, 200, 300, 400, 500, 600, 700, 800]))
```
>> 전체 시간 복잡도: `O(N)`
>> * `len(nums)` -> O(1)
>> * `set(nums)` -> O(N)
>> * `len(set(nums))` -> O(1)


### references 
```
def solution(nums):
    n = len(nums)
    cnt = 1
    nums.sort() 
    for i in range(1, n):
        if nums[i-1] != nums[i]:
            cnt += 1
            
    return cnt if cnt < n//2 else n//2
```
>> 전체 시간 복잡도: O(nlogn)
>> * `nums.sort()` -> O(nlogn)
>> * `for`문 ->  O(N)

:memo: 공간복잡도 측면에서는 아래 코드가 효율적이지만 데이터의 크기가 커질수록 위 코드를 활용해서 o(n)으로 구현하는 게 효율적 





