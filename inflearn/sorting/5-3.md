# 두 수의 합 

:paperclip: array(2-6), hash table(3-6) 참고 

### 문제 설명 
정수 수열 안에서 수열의 원소 두 개의 합이 target값이 되는 경우를 찾고 싶습니다.
매개변수 nums에 길이가 n인 수열이 주어지고, 매개변수 target에 자연수 값이 주어지면 이
수열안에서 두 개의 원소의 합이 정수 target값이 되는 두 원소를 구해 배열에 오름차순으로
담아 반환합니다.
두 개의 원소의 합이 target값이 되는 경우는 오직 한가지 뿐인 입력만 주어집니다.
한 원소를 두 번 더하는 것은 안됩니다. 
nums의 각 원소는 유일값입니다. 답이 없을 경우 [0, 0]을 반환합니다.

### 입출력 예
|nums| target| answer|
|---|---|---|
|[7, 3, 2, 13, 9, 15, 8, 11] |12| [3, 9]|
|[21, 12, 30, 15, 6, 2, 9, 19, 14] |24 |[9, 15]|
|[12, 18, 5, 8, 21, 27, 22, 25, 16, 2]| 28| [12, 16]|
|[11, 17, 6, 8, 21, 9, 19, 12, 25, 16, 2] |26| [9, 17]|
|[7, 5, 12, -9, -12, 22, -30, -35, -21]| -14| [-21, 7]|
|[7, 5, 12, 20]| 15| [0, 0]|

### 제한사항:
* nums의 길이 3 <= n <= 200,000
* 배열 nums의 원소는 정수입니다. -10,000 <= nums[i] <= 10,000
* -20,000 <= target <= 20,000

### references 
:memo: nums의 길이가 20만이므로 `o(n)`이나 `o(nlogn)`으로 풀어야 함.

1. o(n^2)
```
def solution(nums, target):
	n = len(nums)
	for i in range(n):
		for j in range(i+1, n):
			if nums[i] + nums[j] == target:
				return sorted([nums[i], nums[j]])
	return [0, 0]
```

2. o(n)
```
from collections import defaultdict
def solution(nums, target):
    dict = defaultdict(int) # 비어있는 dict 생성 
    
    # 한번 for문을 돌고 자기 앞에 key값하고만 비교하는 것 
    for n in nums:
        if target - n in dict: # dict 안에 값이 존재하는지 확인 
            return sorted([target-n, n])
        dict[n] = 1 # key값이 존재했음을 알려주는 것(dict에 값이 추가됨) 
            
    return [0, 0]
``` 

3. o(nlogn)
```
def solution(nums, target):
    nums.sort()
    left = 0
    right = len(nums) - 1
	# 정렬 후 양 끝에서 투 포인터로 좁혀가며 합을 확인 
    while left < right:
        sumN = nums[left] + nums[right]
        if sumN == target:
            return [nums[left], nums[right]]
        if sumN < target: # target값이 sum값보다 더 큰 경우 더하는 숫자의 크기를 키워야 함 
            left += 1
        else: # target값이 sum값보다 작은 경우 두 숫자의 크기를 줄여야 함
            right -= 1
    return [0, 0]
```


