# 두 수의 차

### 문제 설명 
매개변수 nums에 수열이 주어지면 수열의 원소 중 두 수의 차가 가장 작은 쌍을 찾아 반환하는 프로그램을 작성하세요.
수열의 원소는 유일값들로 이루어져 있습니다. 
두 수의 차가 가장 작은 쌍이 여러개면 모든 쌍을 배열에 담아 반환합니다. 
배열에 담는 순서는 상관없습니다. 
단 두 수는 오름차순 정렬된 쌍으로 표현합니다. 정확성, 효율성 테스트를 합니다.

### 입출력 예
|nums| answer|
|---|---|
|[3, 8, 1, 5, 12] |[[1, 3], [3, 5]]|
|[2, 1, 3, 5, 4] |[[1, 2], [2, 3], [3, 4], [4, 5]]|
|[5, 10, 15, 20, 25, 11] |[[10, 11]]|
|[2, 4, 3, 1, 5, 7, 8, 12, 13, 15, 23]| [[2, 3], [1, 2], [3, 4], [4, 5], [7, 8], [12, 13]]|
|[100, 200, 300, 400, 120, 130, 135, 132, 121] |[[120, 121]]|

### 제한사항:
* nums의 길이는 100,000을 넘지 않습니다.
* 1 <= nums[i] <= 1,000

### solution 
```
def solution(nums):
    answer = []
    nums.sort()
    mins = 1000 # 두 수의 차이값 중 작은 값을 의미하는 변수 
    
    for i in range(0, len(nums)-1): # 정렬이 된 상태이므로 바로 앞, 뒤 변수와의 차이만 비교하면 됨 
        if nums[i+1] - nums[i] < mins: # 더 작은 최소값이 존재하는 경우 
            mins = nums[i+1] - nums[i] # min값 바꾸기 
            answer = [] # 기존에 저장해둔 값 초기화
            answer.append([nums[i], nums[i+1]]) # 새로운 초기값을 갖는 원소쌍 넣기 
        elif nums[i+1] - nums[i] == mins: # 동일한 최소값을 가지는 
            answer.append([nums[i], nums[i+1]])
    return answer 


print(solution([3, 8, 1, 5, 12]))
print(solution([2, 1, 3, 5, 4]))
print(solution([5, 10, 15, 20, 25, 11]))
print(solution([2, 4, 3, 1, 5, 7, 8, 12, 13, 15, 23]))
print(solution([100, 200, 300, 400, 120, 130, 135, 132, 121]))
```
> * 전체 시간 복잡도: o(nlogn)
> * 공간 복잡도: o(n)
> 
> -> 최소 차이 쌍을 저장하는 변수 answer는 최악의 경우 o(n)의 복잡도를 필요 


### references
1. 
```
def solution(nums):
    answer = []
    n = len(nums)
    minN = 1000000000
    nums.sort()

	# 최소 차이 구하기 
    for i in range(1, n):
        diff = nums[i] - nums[i-1]
        minN = min(minN, diff)

	# 최소 차이와 같은 쌍 모으기 
    for i in range(1, n):
        diff = nums[i] - nums[i-1]
        if diff == minN:
            answer.append([nums[i-1], nums[i]])
             
    return answer
```
> * 시간복잡도: o(nlogn)
> * 공간복잡도: o(n) 

2. 
```
def solution(nums):
    answer = []
    n = len(nums)
    minN = 1000000000
    for i in range(n):
        for j in range(i+1, n):
            diff = abs(nums[i] - nums[j])
            if diff < minN:
                minN = diff

    for i in range(n):
        for j in range(i+1, n):
            diff = abs(nums[i] - nums[j])
            if diff == minN:
                answer.append(sorted([nums[i], nums[j]]))
                
    return answer
```
> * 시간 복잡도: o(n^2)
> 
> -> 이중 for문이 활용되므로 시간복잡도 o(n^2)










