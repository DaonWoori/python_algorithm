# 중복 제거 

### 문제 설명
오름차순으로 정렬된 수열이 주어지면 중복된 값을 제거하고 유일값으로 구성된 내림차순 수열을 만들고 싶습니다.
매개변수 nums에 길이가 n인 수열이 주어지면 중복된 값을 제거하고 유일값만으로 구성된 내림차순 수열을 배열에 담아 반환하는 프로그램을 작성하세요.

### 입출력 
|nums| answer|
|[0, 1, 1, 1, 2, 2, 2, 3]| [3, 2, 1, 0]|
|[1, 1, 2, 2, 2, 3, 3, 3, 3, 3, 4, 4, 4, 5] |[5, 4, 3, 2, 1]|
|[0, 0, 0, 3, 3, 3, 5, 7, 7, 7]| [7, 5, 3, 0]|
|[1, 2, 3, 4, 5, 6, 7, 7, 7, 8, 9] |[9, 8, 7, 6, 5, 4, 3, 2, 1]|

### 제한사항 
* nums의 길이 3 <= n <= 200,000
* 배열 nums의 원소는 정수입니다. -10,000 <= nums[i] <= 10,000

### solution 
1)
```
def solution(nums):
    return sorted(set(nums), reverse=True)
   
print(solution([0, 1, 1, 1, 2, 2, 2, 3]))
print(solution([1, 1, 2, 2, 2, 3, 3, 3, 3, 3, 4, 4, 4, 5]))
print(solution([0, 0, 0, 3, 3, 3, 5, 7, 7, 7]))
print(solution([1, 2, 3, 4, 5, 6, 7, 7, 7, 8, 9]))
```
> * 중복 제거: O(N)
> * sorted(): O(NlogN)
> => 최종 시간 복잡도는 O(NlogN)임. 

2) 
```
from collections import deque
def solution(nums):
    answer = []

    deck = deque(nums)

    for _ in range(len(nums)):
        n = deck.pop()
        if n not in answer:
            answer.append(n)
        
    return answer
```
> * for문: o(n)
> * not in: o(n)
> => 최종 시간 복잡도는 O(N^2)으로 타임오버 가능성 있음 


### references 
```
from collections import deque

def solution(nums):
    answer = deque()
    answer.appendleft(nums[0])
    for i in range(1, len(nums)):
       if nums[i-1] != nums[i]:
            answer.appendleft(nums[i])
    return list(answer)
```
> * for 반복: O(n)
> * deque.appendleft(): O(1)
> 따라서 최종 시간복잡도는 O(N)

:question: list를 활용해서 `append()`하는 것과 deque를 활용해서 `appendleft()`하는 것을 비교 
> 리스트 append함수도 맨 뒤에 추가하는 것이므로 시간복잡도 o(1)이다. 





