# 청소 로봇(ver 2)

### 문제 설명 
이차원 배열 격자판 0행 0열이 청소 로봇의 시작위치입니다.

청소 로봇은 다음 규칙에 따라 이동합니다.
1. 'U' 명령은 로봇이 위쪽으로 한 칸 이동합니다.
2. 'R' 명령은 로봇이 오른쪽으로 한 칸 이동합니다
3. 'L' 명령은 로봇이 왼쪽으로 한 칸 이동합니다.
4. 'D' 명령은 로봇이 아래쪽으로 한 칸 이동합니다.
5. 만약 로봇이 명령을 수행할 경우 격자판 밖으로 나가는 경우라면 로봇은 해당 명령을 수행
하지 않고 무시합니다.

매개변수 n에 격자판 크기가 주어지고, moves에 청소 로봇에 명령을 내린 문자들이 차례대로
나열된 명령 문자열이 주어지면 청소 로봇이 최종적으로 멈춘 위치를 반환하는 프로그램을 작성하세요.

### 입출력 예
|n |moves| answer|
|-|---|---|
|5 |'RRRDDDUUUUUUL'| [0, 2]|
|7 |'DDDRRRDDLL' |[5, 1]|
|5 |'RRRRRDDDDDU' |[3, 4]|
|6 |'RRRRDDDRRDDLLUU' |[3, 3]|

### 제한사항:
* moves의 길이는 100을 넘지 않습니다.
* 3 <= n <= 50

### solution
```
def solution(n, moves):
	x = y = 0
    rules = {'U': [-1, 0],
            'R': [0, 1],
            'D': [1, 0],
            'L': [0, -1]}

    for m in moves:
        dx, dy = x + rules[m][0], y + rules[m][1]

        if dx >= 0 and dx < n and dy >= 0 and dy < n:
            x, y = dx, dy
        
    return [x, y]
                            
print(solution(5, 'RRRDDDUUUUUUL'))
print(solution(7, 'DDDRRRDDLL'))
print(solution(5, 'RRRRRDDDDDU'))
print(solution(6, 'RRRRDDDRRDDLLUU'))
```

### references
```
def solution(n, moves):
    dx = [-1, 0, 1, 0]
    dy = [0, 1, 0, -1]
    dir = ['U', 'R', 'D', 'L']
    x = y = 0
    for c in moves:
        for k in range(4):
            if c == dir[k]:
                nx = x + dx[k]
                ny = y + dy[k]

        if nx < 0 or nx >= n or ny < 0 or ny >= n:
            continue

        x = nx
        y = ny
 
    return [x, y]    
```