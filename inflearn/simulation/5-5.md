# 위험 지역

### 문제 설명
n * n 이차원 배열에 특정 지역의 지뢰정보가 지도로 주어집니다.

만약 아래와 같이 5 * 5의 지도에 지뢰정보가 주어지면

0 0 0 0 0

0 1 0 0 0

0 0 0 1 0

0 0 0 0 0

0 0 0 0 0

위에 지도에서 1은 지뢰가 매설된 지역이고 0은 빈땅입니다.
위에 지도에서 지뢰가 매설된 격자와 상하좌우 대각선으로 인접한 8개의 빈땅 격자를 위험지역입니다. 
위에 지도에서 위험지역은 총 14개입니다.
매개변수 board에 특정지역의 지뢰정보가 담겨진 지도가 주어지면 이 지역에 위험지역이 총 몇 개 있는지 반환하는 프로그램을 작성하세요.

### 입출력 예
|board| answer|
|---|---|
|[[0, 0, 0, 0, 0], [0, 1, 0, 0, 0], [0, 0, 0, 1, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]] |14|
|[[1, 0, 0, 1, 0], [0, 1, 0, 0, 0], [0, 1, 0, 1, 0], [0, 0, 0, 0, 0], [0, 1, 0, 0, 0]] |17|
|[[0, 1, 0, 0, 0, 1], [0, 1, 1, 0, 0, 0], [0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, 1], [1, 0, 0, 0, 0, 0], [1, 0, 0, 1, 0, 0]] |26|
|[[0, 1, 0, 0, 0, 1, 0], [0, 1, 1, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 1], [0, 0, 0, 0, 0, 1, 0], [1, 0, 0, 0, 0, 0, 0], [1, 0, 0, 1, 0, 0, 1], [1, 0, 0, 1, 0, 0, 0]]|36|

### 제한사항
* 3 <= n <= 30

### solution
```
def solution(board):
    answer = 0
    dx = [-1, -1, 0, 1, 1, 1, 0, -1]
    dy = [0, 1, 1, 1, 0, -1, -1, -1]

    risk = list()

    for i in range(len(board)):
        for j in range(len(board)):
            for k in range(8):
                nx, ny = i + dx[k], j + dy[k]
                if board[i][j] == 1 and nx >= 0 and nx < len(board) and ny >= 0 and ny < len(board) and board[nx][ny] != 1:
                    risk.append((nx, ny))
   
    
    return len(set(risk))
                       
print(solution([[0, 0, 0, 0, 0], [0, 1, 0, 0, 0], [0, 0, 0, 1, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]]))
print(solution([[1, 0, 0, 1, 0], [0, 1, 0, 0, 0], [0, 1, 0, 1, 0], [0, 0, 0, 0, 0], [0, 1, 0, 0, 0]]))
print(solution([[0, 1, 0, 0, 0, 1], [0, 1, 1, 0, 0, 0], [0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, 1], [1, 0, 0, 0, 0, 0], [1, 0, 0, 1, 0, 0]]))
print(solution([[0, 1, 0, 0, 0, 1, 0], [0, 1, 1, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 1], [0, 0, 0, 0, 0, 1, 0], [1, 0, 0, 0, 0, 0, 0], [1, 0, 0, 1, 0, 0, 1], [1, 0, 0, 1, 0, 0, 0]]))
```

### references 
```
def solution(board):
    answer = 0
    dx=[-1, -1, 0, 1, 1, 1, 0, -1]
    dy=[0, 1, 1, 1, 0, -1, -1, -1]
    n = len(board)
    for i in range(n):
        for j in range(n):
            if board[i][j] == 1:
                for k in range(8):
                    nx = i + dx[k]
                    ny = j + dy[k]
                    if nx >= 0 and nx < n and ny >= 0 and ny < n and board[nx][ny] == 0:
                        answer += 1
                        board[nx][ny] = 2
    
    return answer
```
> 값이 1일 때만 for문 수행함으로써 수행시간을 줄이고, 이미 개수에 포함된 부분의 값을 2로 바꿈으로써 다음에 또 포함될 경우를 제거함. 


