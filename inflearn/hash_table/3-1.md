# 빈도수(ver1)

### 문제 설명 
매개변수 nums에 길이가 n인 수열이 주어지면 수열의 원소중에서 빈도수가 1인 가장 큰 숫자
를 반환하는 프로그램을 작성하세요. 빈도수 1인 숫자가 없을 경우 -1를 반환하세요.

### 입출력 예
|nums|answer|
|---|---|
|[3, 9, 2, 12, 9, 12, 8, 7, 9, 12]|8|
|[3, 9, 2, 12, 9, 12, 8, 7, 9, 12]|-1|
| [3, 9, 2, 12, 9, 12, 8, 7, 9, 12]|888|
| [3, 9, 2, 12, 9, 12, 8, 7, 9, 12]| 555|
| [3, 9, 2, 12, 9, 12, 8, 7, 9, 12]|7|

### 제한사항:
* nums 의 길이 3 <= n <= 10,000
* 배열 nums의 원소는 자연수입니다. 1 <= nums[i] <= 1,000

### solution 
```
def solution(nums):
    cnt_dict = dict()

    # 1. 빈도수 딕셔너리 생성 코드
    for n in nums:
        if n in cnt_dict:
            cnt_dict[n] += 1
        else:
            cnt_dict[n] = 1

    # 2. 빈도수가 1인 key값 
    list_a = [key for key in cnt_dict if cnt_dict[key] == 1]
    
    # 3. 최대값 반환 
    return max(list_a) if list_a else -1 
```
> 1. 빈도수 딕셔너리 생성 코드 
> * for 반복문: `O(n)`
> * n in cnt_dict: `O(1)`
> 
> 2. 빈도수가 1인 key값
> * 리스트 컴프리헨션: `O(n)`
>
> 3. 최대값 반환
> * max값 찾기: `O(n)`
>
> 따라서 최종 시간복잡도는 `O(n)`

### references 
:pushpin: 배열 nums의 원소가 1부터 1000까지로 개수가 많지 않기 때문에 direct-address table을 활용해서 구현 가능! -> 배열 활용

1) 
```
def solution(nums):
    answer = -1 
    cnt = [0] * 1001 
    
    # 1. 빈도수 계산 
    for n in nums:
        cnt[n] += 1
    
    # 2. 빈도수가 1인 값 찾기 
    for i in range(1, 1001):
        if cnt[i] == 1:
            answer = max(answer, i)
    return answer              
```
> 1. 빈도수 계산
> * 반복문: `o(n)`
> 
> 2. 빈도수가 1인 값 찾기
> * 고정된 범위를 반복: `o(1)`
>
> 최종 시간복잡도는 `O(n)`

:pushpin: 내가 구현한 방법과 동일한 시간복잡도를 갔지만 빈도수가 1인 값을 찾는 부분에서 리스트를 먼저 생성하므로 추가 메모리가 발생하고, `max(list_a)`에서 
리스트를 또 한번 순회하므로 결국 두 번의 순회가 이뤄지기 때문에 효율성이 떨어짐.
반면, 해당 코드는 입력값의 크기에 영향을 받지 않고 반복문을 순회하고 `max(answer, i)`는 상수시간의 연산이 필요하므로 훨씬 가볍고 빠름. 



2) 
```
def solution(nums):
    answer = -1 
    cnt = [0] * 1001 
    
    for n in nums:
        cnt[n] += 1
    
    for i in range(1000, 0, -1):
        if cnt[i] == 1:
            return i 
    return answer        
```
> 빈도수가 1인 값 중 가장 큰 값의 인덱스를 리턴하는 것이므로, 배열을 뒤에서부터 접근해서 값이 1이면 바로 그 값을 리턴 


